# ğŸ¤— QiuckLearnFromPicture

### GPU åŠ é€Ÿåº”ç”¨ç¨‹åºä¸ CPU åº”ç”¨ç¨‹åºå¯¹æ¯”

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (101).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (102).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (103).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (104).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (105).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (106).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (107).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (108).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (109).png" alt=""><figcaption></figcaption></figure>

### CUDA çº¿ç¨‹å±‚æ¬¡ç»“æ„

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (110).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (111).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (112).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (113).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (114).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (115).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (116).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (117).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (118).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (119).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (120).png" alt=""><figcaption></figcaption></figure>

### CUDA æä¾›çš„çº¿ç¨‹å±‚æ¬¡ç»“æ„å˜é‡

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (121).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (122).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (123).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (124).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (125).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (126).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (127).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (128).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (129).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (130).png" alt=""><figcaption></figcaption></figure>

### åè°ƒå¹¶è¡Œçº¿ç¨‹

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (132).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (133).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (134).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (135).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (136).png" alt=""><figcaption></figcaption></figure>

é€šè¿‡è¿™äº›å˜é‡ï¼Œå…¬å¼ `threadIdx.x + blockIdx.x * blockDim.x` å¯å°†æ¯ä¸ªçº¿ç¨‹æ˜ å°„åˆ°å‘é‡çš„å…ƒç´ ä¸­

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (137).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (138).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (139).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (140).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
<mark style="color:red;">å¿…é¡»ä½¿ç”¨ä»£ç æ£€æŸ¥å¹¶ç¡®ä¿ç»ç”±å…¬å¼</mark> <mark style="color:red;"></mark><mark style="color:red;">`threadIdx.x + blockIdx.x * blockDim.x`</mark> <mark style="color:red;"></mark><mark style="color:red;">è®¡ç®—å‡ºçš„ dataIndex å°äº Nï¼ˆæ•°æ®å…ƒç´ æ•°é‡ï¼‰ã€‚</mark>
{% endhint %}

### ç½‘æ ¼è·¨åº¦å¾ªç¯

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (141).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (142).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (143).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (144).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (145).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (146).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (147).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (148).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (149).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (150).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (151).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (152).png" alt=""><figcaption></figcaption></figure>

```c
#include <stdio.h>

void init(int *a, int N)
{
  int i;
  for (i = 0; i < N; ++i)
  {
    a[i] = i;
  }
}

__global__
void doubleElements(int *a, int N)
{
  int idx = blockIdx.x * blockDim.x + threadIdx.x;
  int stride = gridDim.x * blockDim.x;

  for (int i = idx; i < N; i += stride)
  {
    a[i] *= 2;
  }
}

bool checkElementsAreDoubled(int *a, int N)
{
  int i;
  for (i = 0; i < N; ++i)
  {
    if (a[i] != i*2) return false;
  }
  return true;
}

int main()
{
  int N = 10000;
  int *a;

  size_t size = N * sizeof(int);
  cudaMallocManaged(&a, size);

  init(a, N);

  size_t threads_per_block = 256;
  size_t number_of_blocks = 32;

  doubleElements<<<number_of_blocks, threads_per_block>>>(a, N);
  cudaDeviceSynchronize();

  bool areDoubled = checkElementsAreDoubled(a, N);
  printf("All elements were doubled? %s\n", areDoubled ? "TRUE" : "FALSE");

  cudaFree(a);
}
```

### å¹¶å‘ CUDA æµ

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (2).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (3).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (4).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (6).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (7).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (8).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (9).png" alt=""><figcaption></figcaption></figure>

é»˜è®¤æµä¸éé»˜è®¤æµä¸­çš„æ“ä½œä¸ä¼šå‘ç”Ÿé‡å ã€‚

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (10).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
&#x20;<mark style="color:red;">é»˜è®¤æµè¾ƒä¸ºç‰¹æ®Šã€‚é»˜è®¤æµä¸­æ‰§è¡Œä»»ä½•æ“ä½œæœŸé—´ï¼Œä»»ä½•éé»˜è®¤æµä¸­çš†ä¸å¯åŒæ—¶æ‰§è¡Œä»»ä½•æ“ä½œï¼Œ</mark><mark style="color:red;">**é»˜è®¤æµå°†ç­‰å¾…éé»˜è®¤æµå…¨éƒ¨æ‰§è¡Œå®Œæ¯•åå†å¼€å§‹è¿è¡Œï¼Œè€Œä¸”åœ¨å…¶æ‰§è¡Œå®Œæ¯•åï¼Œå…¶ä»–éé»˜è®¤æµæ‰èƒ½å¼€å§‹æ‰§è¡Œã€‚**</mark>
{% endhint %}

#### **ä½¿ç”¨æµå°†å¤åˆ¶å’Œè®¡ç®—è¿›è¡Œé‡å **

é€šè¿‡ä½¿ç”¨é»˜è®¤æµï¼Œå…¸å‹çš„ä¸‰æ­¥å¼ CUDA ç¨‹åºä¼šé¡ºæ¬¡æ‰§è¡Œ HtoD å¤åˆ¶ã€è®¡ç®—å’Œ DtoH å¤åˆ¶ï¼ˆä¸ºä¾¿äºæ¼”ç¤ºï¼Œä¸‹é¢çš„å›¾ç‰‡ä¸­ä½¿ç”¨ç®€ç•¥ä»£ç ï¼‰ï¼Œå¦‚ä¸‹å›¾ï¼š

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (11).png" alt=""><figcaption></figcaption></figure>

ä½†æ˜¯è¿™æ ·æ˜æ˜¾æ˜¯ä¸å¯è¡Œçš„ã€‚å›å¿†ä¸€ä¸‹ï¼Œéé»˜è®¤æµä¸­çš„æ“ä½œé¡ºåºä¸å›ºå®šï¼Œå› æ­¤å¯èƒ½ä¼šå‡ºç°è¿™ç§æƒ…å†µï¼š

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (12).png" alt=""><figcaption></figcaption></figure>

åœ¨å…¶æ‰€éœ€çš„æ•°æ®ä¼ è¾“åˆ° GPU ä¹‹å‰ï¼Œè®¡ç®—å¯èƒ½ä¾¿ä¼šå¼€å§‹ï¼Œ

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (13).png" alt=""><figcaption></figcaption></figure>

æˆ‘ä»¬è¿˜å¯é‡‡ç”¨å¦ä¸€ç§åˆçº§åšæ³•ï¼šå°†æ‰€æœ‰æ“ä½œå…¨éƒ¨å‘å¸ƒåœ¨åŒä¸€ä¸ªéé»˜è®¤æµä¸­ï¼Œä»¥ç¡®ä¿æ•°æ®å’Œè®¡ç®—çš„é¡ºåºï¼Œ

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (14).png" alt=""><figcaption></figcaption></figure>

ä½†è¿™æ ·åšä¸ä½¿ç”¨é»˜è®¤æµæ²¡æœ‰åŒºåˆ«ï¼Œç»“æœæ˜¯ä¾ç„¶æ²¡æœ‰é‡å ã€‚æ€è€ƒä¸€ä¸‹ï¼Œå¦‚æœé‡‡ç”¨ç°æœ‰ç¨‹åºå¹¶å°†æ•°æ®åˆ†ä¸º 2 å—

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (15).png" alt=""><figcaption></figcaption></figure>

**å¦‚æœç°å°†é’ˆå¯¹æ¯ä¸ªæ•°æ®å—çš„æ‰€æœ‰æ“ä½œç§»è‡³å…¶å„è‡ªç‹¬ç«‹çš„éé»˜è®¤æµ**ï¼Œæ•°æ®å’Œè®¡ç®—é¡ºåºå¾—ä»¥ä¿æŒï¼ŒåŒæ—¶èƒ½å¤Ÿå®ç°éƒ¨åˆ†é‡å ã€‚

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (16).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (17).png" alt=""><figcaption></figcaption></figure>

æ ¹æ®å‡è®¾ï¼Œé€šè¿‡å¢åŠ æ•°æ®å—æ•°é‡ï¼Œé‡å æ•ˆæœå¯èƒ½æ›´å¥½ã€‚è¦è·å¾—ç†æƒ³çš„åˆ†å—æ•°é‡ï¼Œæœ€å¥½çš„é€”å¾„æ˜¯è§‚å¯Ÿç¨‹åºæ€§èƒ½ã€‚

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (18).png" alt=""><figcaption></figcaption></figure>

å°†æ•°æ®åˆ†å—ä»¥åœ¨å¤šä¸ªæµä¸­ä½¿ç”¨æ—¶ï¼Œç´¢å¼•å¯èƒ½è¾ƒä¸ºæ£˜æ‰‹ã€‚è®©æˆ‘ä»¬é€šè¿‡å‡ ä¸ªç¤ºä¾‹äº†è§£ä¸€ä¸‹å¦‚ä½•è¿›è¡Œç´¢å¼•ã€‚é¦–å…ˆä¸ºæ‰€æœ‰æ•°æ®å—åˆ†é…æ‰€éœ€æ•°æ®ï¼Œä¸ºä½¿ç¤ºä¾‹æ›´åŠ æ¸…æ™°ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†è¾ƒå°è§„æ¨¡çš„æ•°æ®ã€‚

1. ä¸ºCPUå’ŒGPUåˆ†é…å†…å­˜ï¼ˆNè¡¨ç¤ºæ€»çš„æ•°æ®é‡ï¼‰ï¼›

```c
cudaMallocHost(&data_cpu, N)
cudaMalloc(&data_gpu, N)
```

2. æ¥ä¸‹æ¥ï¼Œå®šä¹‰æµçš„æ•°é‡ï¼Œå¹¶é€šè¿‡æ‰§è¡Œå¾ªç¯ä»£ç ä»¥æ•°ç»„å½¢å¼åˆ›å»ºå’Œæ”¶é›†æµï¼ˆæ­¤å¤„å®šä¹‰çš„æµçš„æ•°é‡ä¸º2ï¼‰ï¼›

```c
num_streams = 2
for stream_i in num_streams
	cudaStreamCreate(stream)
	streams[stream_i] = stream
```

3. æ¯ä¸ªæ•°æ®å—çš„å¤§å°å–å†³äºæ•°æ®æ¡ç›®çš„æ•°é‡ä»¥åŠæµçš„æ•°é‡ï¼›

```c
chunk_size = N / num_streams
```

4. æ¯ä¸ªæµéœ€è¦å¤„ç†ä¸€ä¸ªæ•°æ®å—ï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®—å…¶åœ¨æ•´ä¸ªæ•°æ®é›†ä¸­çš„ç´¢å¼•ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å°†éå†æµçš„æ•°é‡ï¼Œä» 0 å¼€å§‹ç„¶åä¹˜ä»¥æ•°æ®å—å¤§å°ã€‚ä» lower ç´¢å¼•å¼€å§‹ï¼Œå¹¶ä½¿ç”¨ä¸€ä¸ªæ•°æ®å—å¤§å°çš„æ•°æ®ï¼Œå¦‚æ­¤å³å¯ä»å…¨éƒ¨æ•°æ®ä¸­è·å¾—æµæ•°æ®ï¼Œæ­¤æ–¹æ³•å°†ä¼šåº”ç”¨è‡³æ¯ä¸€ä¸ª stream\_iï¼›

```c
for stream_i in num_streams
	lower = chunk_size*stream_i
```

5. è®¡ç®—å®Œè¿™äº›å€¼åï¼Œæˆ‘ä»¬ç°åœ¨å³å¯æ‰§è¡Œéé»˜è®¤æµ HtoD å†…å­˜å¤åˆ¶ï¼›

```c
cudaMemcpyAsync(
	data_cpu+lower,
	data_gpu+lower, 	sizeof(uint64_t)*chunk_size, 	cudaMemcpyHostToDevice,
	streams[stream_i]
)
```

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (20).png" alt=""><figcaption></figcaption></figure>

&#x20;ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼ŒN è¢«æµæ•°é‡æ•´é™¤ã€‚å¦‚æœä¸èƒ½æ•´é™¤å‘¢ï¼Ÿ**ä¸ºè§£å†³è¯¥é—®é¢˜ï¼Œæˆ‘ä»¬ä½¿ç”¨å‘ä¸Šå–æ•´çš„é™¤æ³•è¿ç®—æ¥è®¡ç®—æ•°æ®å—å¤§å°**ã€‚ä½†æ˜¯è¿™è¿˜æ˜¯ä¼šæœ‰é—®é¢˜ï¼Œå¦‚ä¸‹å›¾ï¼š

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (21).png" alt=""><figcaption></figcaption></figure>

æˆ‘ä»¬ç¡®å®å¯ä»¥è®¿é—®æ‰€æœ‰æ•°æ®ï¼Œä½†åˆäº§ç”Ÿäº†æ–°é—®é¢˜ï¼š<mark style="color:red;">å¯¹äºæœ€åä¸€ä¸ªæ•°æ®å—è€Œè¨€ï¼Œæ•°æ®å—å¤§å°è¿‡å°ï¼Œå­˜åœ¨çº¿ç¨‹è®¿é—®è¶Šç•Œçš„é—®é¢˜ã€‚</mark>

è§£å†³æ–¹æ³•å¦‚ä¸‹ï¼š

1. ä¸ºæ¯ä¸ªæ•°æ®å—è®¡ç®— upper ç´¢å¼•ï¼ˆä¸å¾—è¶…è¿‡ Nï¼‰ï¼›

```c
upper = min(lower+chunk_size, N)
```

2. ç„¶åä½¿ç”¨ upper å’Œ lower è®¡ç®—æ•°æ®å— widthï¼›

```c
width = upper - lower
```

3. ç°åœ¨ä½¿ç”¨ width è€Œéæ•°æ®å—å¤§å°è¿›è¡Œè¿­ä»£ï¼›

<figure><img src="../../.gitbook/assets/å›¾ç‰‡ (22).png" alt="" width="563"><figcaption></figcaption></figure>

è¿™æ ·æˆ‘ä»¬å°±èƒ½å®Œç¾é€‚é…æ•°æ®ï¼Œè€Œä¸å—å…¶å¤§å°æˆ–æµæ•°é‡çš„å½±å“ã€‚

**å¤åˆ¶ä¸è®¡ç®—é‡å çš„ä»£ç ç¤ºä¾‹**

```c
// Able to handle when `num_entries % num_streams != 0`.

const uint64_t num_entries = 10;
const uint64_t num_iters = 1UL << 10;

cudaMallocHost(&data_cpu, sizeof(uint64_t)*num_entries);
cudaMalloc    (&data_gpu, sizeof(uint64_t)*num_entries);

// Set the number of streams to not evenly divide num_entries.
const uint64_t num_streams = 3;

cudaStream_t streams[num_streams];
for (uint64_t stream = 0; stream < num_streams; stream++)
    cudaStreamCreate(&streams[stream]);

// Use round-up division (`sdiv`, defined in helper.cu) so `num_streams*chunk_size`
// is never less than `num_entries`.
// This can result in `num_streams*chunk_size` being greater than `num_entries`, meaning
// we will need to guard against out-of-range errors in the final "tail" stream (see below).
const uint64_t chunk_size = sdiv(num_entries, num_streams);

for (uint64_t stream = 0; stream < num_streams; stream++) {

    const uint64_t lower = chunk_size*stream;
    // For tail stream `lower+chunk_size` could be out of range, so here we guard against that.
    const uint64_t upper = min(lower+chunk_size, num_entries);
    // Since the tail stream width may not be `chunk_size`,
    // we need to calculate a separate `width` value.
    const uint64_t width = upper-lower;

    // Use `width` instead of `chunk_size`.
    cudaMemcpyAsync(data_gpu+lower, data_cpu+lower, 
           sizeof(uint64_t)*width, cudaMemcpyHostToDevice, 
           streams[stream]);

    // Use `width` instead of `chunk_size`.
    decrypt_gpu<<<80*32, 64, 0, streams[stream]>>>
        (data_gpu+lower, width, num_iters);

    // Use `width` instead of `chunk_size`.
    cudaMemcpyAsync(data_cpu+lower, data_gpu+lower, 
           sizeof(uint64_t)*width, cudaMemcpyDeviceToHost, 
           streams[stream]);
}

// Destroy streams.
for (uint64_t stream = 0; stream < num_streams; stream++)
    cudaStreamDestroy(streams[stream]);

```

å®Œæ•´ä»£ç å¦‚ä¸‹ï¼š

```c
#include <cstdint>
#include <iostream>
#include "helpers.cuh"
#include "encryption.cuh"

void encrypt_cpu(uint64_t * data, uint64_t num_entries, 
                 uint64_t num_iters, bool parallel=true) {

    #pragma omp parallel for if (parallel)
    for (uint64_t entry = 0; entry < num_entries; entry++)
        data[entry] = permute64(entry, num_iters);
}

__global__ 
void decrypt_gpu(uint64_t * data, uint64_t num_entries, 
                 uint64_t num_iters) {

    const uint64_t thrdID = blockIdx.x*blockDim.x+threadIdx.x;
    const uint64_t stride = blockDim.x*gridDim.x;

    for (uint64_t entry = thrdID; entry < num_entries; entry += stride)
        data[entry] = unpermute64(data[entry], num_iters);
}

bool check_result_cpu(uint64_t * data, uint64_t num_entries,
                      bool parallel=true) {

    uint64_t counter = 0;

    #pragma omp parallel for reduction(+: counter) if (parallel)
    for (uint64_t entry = 0; entry < num_entries; entry++)
        counter += data[entry] == entry;

    return counter == num_entries;
}

int main (int argc, char * argv[]) {

    Timer timer;
    Timer overall;

    const uint64_t num_entries = 1UL << 26;
    const uint64_t num_iters = 1UL << 10;
    const bool openmp = true;

    // Define the number of streams.
    const uint64_t num_streams = 32;
    
    // Use round-up division to calculate chunk size.
    const uint64_t chunk_size = sdiv(num_entries, num_streams);

    timer.start();
    uint64_t * data_cpu, * data_gpu;
    cudaMallocHost(&data_cpu, sizeof(uint64_t)*num_entries);
    cudaMalloc    (&data_gpu, sizeof(uint64_t)*num_entries);
    timer.stop("allocate memory");
    check_last_error();

    timer.start();
    encrypt_cpu(data_cpu, num_entries, num_iters, openmp);
    timer.stop("encrypt data on CPU");

    timer.start();
    
    // Create array for storing streams.
    cudaStream_t streams[num_streams];
    
    // Create number of streams and store in array.
    for (uint64_t stream = 0; stream < num_streams; stream++)
        cudaStreamCreate(&streams[stream]);
    timer.stop("create streams");
    check_last_error();

    overall.start();
    timer.start();
    
    // For each stream...
    for (uint64_t stream = 0; stream < num_streams; stream++) {
        
        // ...calculate index into global data (`lower`) and size of data for it to process (`width`).
        const uint64_t lower = chunk_size*stream;
        const uint64_t upper = min(lower+chunk_size, num_entries);
        const uint64_t width = upper-lower;

        // ...copy stream's chunk to device.
        cudaMemcpyAsync(data_gpu+lower, data_cpu+lower, 
               sizeof(uint64_t)*width, cudaMemcpyHostToDevice, 
               streams[stream]);

        // ...compute stream's chunk.
        decrypt_gpu<<<80*32, 64, 0, streams[stream]>>>
            (data_gpu+lower, width, num_iters);

        // ...copy stream's chunk to host.
        cudaMemcpyAsync(data_cpu+lower, data_gpu+lower, 
               sizeof(uint64_t)*width, cudaMemcpyDeviceToHost, 
               streams[stream]);
    }

    for (uint64_t stream = 0; stream < num_streams; stream++)
	// Synchronize streams before checking results on host.
        cudaStreamSynchronize(streams[stream]);    
    
    // Note modification of timer instance use.
    timer.stop("asynchronous H2D->kernel->D2H");
    overall.stop("total time on GPU");
    check_last_error();
    
    timer.start();
    const bool success = check_result_cpu(data_cpu, num_entries, openmp);
    std::cout << "STATUS: test " 
              << ( success ? "passed" : "failed")
              << std::endl;
    timer.stop("checking result on CPU");

    timer.start();      
    for (uint64_t stream = 0; stream < num_streams; stream++)
        // Destroy streams.
        cudaStreamDestroy(streams[stream]);    
    timer.stop("destroy streams");
    check_last_error();

    timer.start();
    cudaFreeHost(data_cpu);
    cudaFree    (data_gpu);
    timer.stop("free memory");
    check_last_error();
}

```

### reference

* [https://blog.csdn.net/qq\_31985307/article/details/126237070](https://blog.csdn.net/qq\_31985307/article/details/126237070)
* [https://learn.nvidia.com/courses/course-detail?course\_id=course-v1:DLI+S-AC-04+V1-ZH](https://learn.nvidia.com/courses/course-detail?course\_id=course-v1:DLI+S-AC-04+V1-ZH)
